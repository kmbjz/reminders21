package main

import (
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/joho/godotenv"
	_ "github.com/mattn/go-sqlite3"
)

const llmPrompt = `
Analyze the following user input. It's a user request to remind about something in specific time. Your goal is define:
• requested reminder's date and time ("datetime" field). if the user didn't provide date then use today date. the user allowed to provide relative date or time, for example "today", "tomorrow", "in 10 minutes", "after 1 hour", etc. – in this case calculate datetime based on current datetime: %s. 
• label for reminder ("label" field)
• generate answer to user in Russian language contained parsed datetime and label. for example: "Принято. <human-readable representation of datetime> напомню тебе о <human-readable label>".
Output Requirements:
•  Output must be in valid JSON with UTF-8 encoded strings.
•  The JSON structure should be: {"datetime": "", "label": "", "answer": ""}
•  If you cannot generate any field, leave it empty in the JSON.
•  Escape double quotes " by prefixing them with a backslash \.
•  Do not escape other characters.
•  Do not add extra formatting, line breaks, reasoning or any additional text outside the JSON structure.
`

var (
	db  *sql.DB
	bot *tgbotapi.BotAPI
)

// LLMOutput represents the JSON structure we expect from the LLM.
type LLMOutput struct {
	Datetime string `json:"datetime"`
	Label    string `json:"label"`
	Answer   string `json:"answer"`
}

func main() {
	// Load environment variables from .env file.
	err := godotenv.Load()
	if err != nil {
		log.Printf("Error loading .env file: %v", err)
	}

	// Open (or create) the SQLite database
	db, err = sql.Open("sqlite3", "reminders.db")
	if err != nil {
		log.Fatalf("Error opening DB: %v", err)
	}
	defer db.Close()

	db.SetMaxOpenConns(1)

	// Create reminders table if it doesn't exist
	createTableSQL := `
	CREATE TABLE IF NOT EXISTS reminders (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		chat_id INTEGER,
		user_id INTEGER,
		reminder_time DATETIME,
		label TEXT,
		notified INTEGER DEFAULT 0
	);`
	_, err = db.Exec(createTableSQL)
	if err != nil {
		log.Fatalf("Error creating table: %v", err)
	}

	// Retrieve Telegram bot token from environment variables.
	botToken := os.Getenv("TELEGRAM_BOT_TOKEN")
	if botToken == "" {
		log.Fatalf("TELEGRAM_BOT_TOKEN is not set in environment")
	}

	// Initialize Telegram Bot
	bot, err = tgbotapi.NewBotAPI(botToken)
	if err != nil {
		log.Fatalf("Error creating bot: %v", err)
	}
	log.Printf("Authorized on account %s", bot.Self.UserName)

	// Start the background goroutine that checks for due reminders
	go checkReminders()

	// Set up update configuration
	u := tgbotapi.NewUpdate(0)
	u.Timeout = 60

	updates := bot.GetUpdatesChan(u)

	// Process incoming messages
	for update := range updates {
		if update.Message != nil {
			handleMessage(update.Message)
		}
	}
}

// handleMessage parses the incoming message via the LLM, stores the reminder,
// and replies with the answer generated by LLM.
func handleMessage(msg *tgbotapi.Message) {
	// Call the LLM to parse the message.
	reminderTime, label, answer, err := parseMessageWithLLM(msg.Text)
	if err != nil {
		log.Printf("LLM parse error: %v", err)
		reply := tgbotapi.NewMessage(msg.Chat.ID, "Ошибка распознования запроса. Попробуй сформулировать по-другому.")
		bot.Send(reply)
		return
	}

	// Insert the reminder into the database
	_, err = db.Exec("INSERT INTO reminders (chat_id, user_id, reminder_time, label) VALUES (?, ?, ?, ?)",
		msg.Chat.ID, msg.From.ID, reminderTime, label)
	if err != nil {
		log.Printf("DB insert error: %v", err)
		reply := tgbotapi.NewMessage(msg.Chat.ID, "Error storing reminder")
		bot.Send(reply)
		return
	}

	// Log the accepted reminder
	log.Printf("Accepted reminder: '%s' at %s for chat ID %d", label, reminderTime.Format("2006-01-02 15:04:05"), msg.Chat.ID)

	// Acknowledge the reminder creation using the answer provided by the LLM.
	reply := tgbotapi.NewMessage(msg.Chat.ID, answer)
	bot.Send(reply)
}

// parseMessageWithLLM calls the OpenAI API to parse the user input.
// It sends a prompt asking to analyze the input and output JSON with three keys:
// "datetime", "label" and "answer". The datetime should be in the format YYYY-MM-DD HH:MM,
// label is a short description, and answer is the confirmation message in the format:
// "Принято. <datetime> напомню тебе о <label>".
func parseMessageWithLLM(input string) (time.Time, string, string, error) {
	openaiAPIKey := os.Getenv("OPENAI_API_KEY")
	if openaiAPIKey == "" {
		return time.Time{}, "", "", fmt.Errorf("OPENAI_API_KEY is not set in environment")
	}

	// Prepare request payload for the Chat Completion endpoint using model "gpt-4o".
	reqBody, err := json.Marshal(map[string]interface{}{
		"model": "gpt-4o",
		"messages": []map[string]string{
			{"role": "developer", "content": fmt.Sprintf(llmPrompt, time.Now().Format("2006-01-02 15:04:05"))},
			{"role": "user", "content": input},
		},
		//"max_tokens":  100,
		//"temperature": 0,
	})
	if err != nil {
		return time.Time{}, "", "", err
	}

	req, err := http.NewRequest("POST", "https://api.openai.com/v1/chat/completions", bytes.NewBuffer(reqBody))
	if err != nil {
		return time.Time{}, "", "", err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+openaiAPIKey)

	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return time.Time{}, "", "", err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return time.Time{}, "", "", err
	}

	// Define a struct to parse the OpenAI response.
	type ChatChoice struct {
		Message struct {
			Content string `json:"content"`
		} `json:"message"`
	}
	type OpenAIChatResponse struct {
		Choices []ChatChoice `json:"choices"`
	}

	var openaiResp OpenAIChatResponse
	err = json.Unmarshal(body, &openaiResp)
	if err != nil {
		return time.Time{}, "", "", err
	}

	if len(openaiResp.Choices) == 0 {
		return time.Time{}, "", "", fmt.Errorf("no choices returned from OpenAI")
	}

	// The model's output should be a JSON string; clean it up.
	outputText := strings.Trim(strings.TrimSpace(openaiResp.Choices[0].Message.Content), "\r\n```json")
	log.Println(outputText)
	// In case the model returns extra text, try to extract the JSON object.
	startIdx := strings.Index(outputText, "{")
	endIdx := strings.LastIndex(outputText, "}")
	if startIdx == -1 || endIdx == -1 || startIdx >= endIdx {
		return time.Time{}, "", "", fmt.Errorf("failed to extract JSON from model output")
	}
	jsonStr := outputText[startIdx : endIdx+1]

	var result LLMOutput
	err = json.Unmarshal([]byte(jsonStr), &result)
	if err != nil {
		return time.Time{}, "", "", fmt.Errorf("error parsing JSON: %v", err)
	}

	reminderTime, err := time.Parse("2006-01-02 15:04:05", result.Datetime)
	if err != nil {
		return time.Time{}, "", "", fmt.Errorf("error parsing datetime: %v", err)
	}

	if strings.TrimSpace(result.Label) == "" {
		return time.Time{}, "", "", fmt.Errorf("label is empty")
	}

	if strings.TrimSpace(result.Answer) == "" {
		return time.Time{}, "", "", fmt.Errorf("answer is empty")
	}

	return reminderTime, result.Label, result.Answer, nil
}

// checkReminders periodically checks the database for reminders
// that are due and sends them to the user.
func checkReminders() {
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()

	for range ticker.C {
		now := time.Now()
		rows, err := db.Query("SELECT id, chat_id, label FROM reminders WHERE reminder_time <= ? AND notified = 0", now)
		if err != nil {
			log.Printf("DB query error: %v", err)
			continue
		}

		for rows.Next() {
			var id int64
			var chatID int64
			var label string
			err := rows.Scan(&id, &chatID, &label)
			if err != nil {
				log.Printf("Row scan error: %v", err)
				continue
			}

			// Send the reminder message to the user
			msg := tgbotapi.NewMessage(chatID, label)
			_, err = bot.Send(msg)
			if err != nil {
				log.Printf("Error sending reminder: %v", err)
				continue
			} else {
				log.Printf("Reminder sent: [%v] %s", chatID, label)
			}

			// Mark the reminder as notified to avoid sending it again
			_, err = db.Exec("UPDATE reminders SET notified = 1 WHERE id = ?", id)
			if err != nil {
				log.Printf("Error updating reminder status: %v", err)
			}
		}
		rows.Close()
	}
}
